ПРОМТ ДЛЯ ПРОЕКТА VFD_AI

Полное описание архитектуры, цели, структуры алгоритмов и оборудования

1. Общая идея проекта

Создаётся универсальный самообучающийся алгоритм управления асинхронным двигателем (АД), который:

Может быть подключён к любому АД без предварительных параметров.

Сам проводит гипотезы → эксперименты → закрепление.

Использует любопытство как механизм исследования и оценки модели ошибки.

Постепенно определяет параметры двигателя, улучшает стратегию управления, минимизирует потери и обеспечивает стабильное управление.

Работает поверх классического базового контроллера (120° инвертор).

В цифровом мире (Python) он обучается бесконечно и адаптивно, а не «один раз и навсегда».

Позже переносится на железо с Arduino Q + STEVAL-IPM15B.

2. Оборудование стенда

Стенд состоит из:

Асинхронный двигатель АИР-56, 0.25 кВт — основной объект управления.

Инвертор STEVAL-IPM15B (1.5 кВт) — силовая часть с 120° коммутацией.

Энкодер Autonics E40S6-2000-3-T-24 — обратная связь по скорости.

Arduino Q — нижний реального времени, силовой контроллер.

Ноутбук — мозг, Python, симуляции, ИИ, RL, цифровая модель.

3. Архитектура управления по уровням
Уровень 0 — аппаратно-защитный слой (Arduino Q)

Ничего умного. Только:

ограничения тока,

dead-time,

защита по перенапряжению,

лимиты duty,

аварийная остановка.

ИИ сюда не лезет вообще.

Уровень 1 — базовый алгоритм инвертора (Arduino Q)

Это классический шести-шаговый 120° инвертор:

генерация таблицы ключевых состояний,

вычисление сектора по углу,

θ_e счётчик, интегрируемый из ω_e_ref,

амплитуда напряжения как U_phase = k_VF * f_e + U_boost.

Дополнительно:

контур скорости по энкодеру,

PI-регулятор скорости → выдаёт ω_e_ref.

ИИ НЕ генерирует PWM и НЕ управляет ключами напрямую.
ИИ только влияет на:

ω_e_ref (скорость поля),

U_phase или параметр k_VF,

небольшой фазовый сдвиг Δθ (тонкая настройка момента),

динамические коэффициенты PI скорости.

Это безопасный и полностью предсказуемый слой.

Уровень 2 — цифровая модель двигателя (Python)

Математическая модель АД (dq-модель):

параметры: Rs, Rr, Lsσ, Lrσ, Lm, J, B, p;

учёт насыщения при необходимости;

динамика в dq-координатах;

обратные преобразования dq→abc;

модель тока, момента, ω.

Также моделируется инвертор:

120° фазовое управление,

ограничения по напряжению и току,

dead-time,

задержки,

квантования АЦП и шумы датчиков.

Добавляются реалистичные шумы и разброс, чтобы ИИ не был слишком избалован чистой моделью.

Допустимая ошибка между Python и Simulink ≈ 5%.

Уровень 3 — универсальный самообучающийся ИИ (Python)

Главный элемент системы.

Структура обучения:
Гипотеза → Проверка → Закрепление
(циклический бесконечный процесс)

3.1. Гипотеза

ИИ хранит следующие внутренние состояния:

гипотезу о параметрах мотора:
θ_params = [Rs, Rr, Lm, Lσs, Lσr, J, B, ...]

неопределённости параметров:
Σ_params (ковариация или интервалы)

гипотезу о стратегии управления (policy_params)

память для долгосрочной адаптации (hidden_state)

3.2. Проверка

ИИ инициирует эксперимент:

меняет ω_e_ref,

варьирует U_phase,

даёт ступеньку момента,

двигает Δθ,

измеряет реакцию (токи, ω, момент, потери).

Все эксперименты подчиняются жёстким ограничениям и защитам уровня 0 и 1.

3.3. Закрепление

ИИ обновляет:

Оценку параметров АД (байесовский апдейт, фильтр Калмана или NN-оцениватель).

Стратегию управления (RL-политика).

Любопытство (intrinsic reward):

вознаграждение за ошибки предсказания модели,

за снижение неопределённости параметров.

Полезное награждение:

reward = 
    -(ошибка скорости/момента)^2 
    - λ * потери
    - штрафы за ограничения
    + бонус любопытства

4. Поведение ИИ в цифровом мире

Алгоритм не «обучается один раз» — он всегда обучается.

Чтобы доказать универсальность алгоритма, в Python генерируется множество виртуальных двигателей:

разные Rs, Rr, Lm, J, B, насыщения,

разные шумы и ограничения,

разные динамики нагрузки.

Один и тот же алгоритм обучения запускается на каждом из них.

Если он стабильно сходится к эффективной стратегии (минимум потерь, стабильное управление, низкие пульсации момента) — значит он действительно универсальный.

Это ключевая научная часть.

5. Этапы реализации в Python
5.1. Построение модели АД

Не фанатично точной. 5% разница от Simulink допустима.

5.2. Реализация двух эталонных контроллеров

Скалярный V/f

Упрощённый FOC (для сравнения)

5.3. Валидация

Сравниваем Python-модель и Simulink по:

токам,

скорости,

переходным процессам.

5.4. Запуск VFD_AI в цифре

ИИ должен:

быстро снижать неопределённость параметров,

улучшать управление,

минимизировать потери,

адаптироваться к любому виртуальному мотору.

6. Перенос на железо

После цифровой отладки:

Arduino Q реализует 120° + контур скорости + защиту.

Ноутбук (Python) — ИИ, оценка параметров и стратегия.

Коммуникация ноут → Arduino:

ω_e_ref,

U_phase,

Δθ,

опционально параметры PI.

ИИ продолжает онлайн-обучаться на реальном моторе.

7. Цель проекта

Создать универсальный адаптивный алгоритм управления асинхронным двигателем, который:

при подключении к ЛЮБОМУ АД

без паспортных данных

проводит самоисследование

определяет параметры

учится эффективному управлению

минимизирует потери

и работает поверх безопасной классической силовой логики.

Это не «нейросетка».
Это алгоритм обучения, устойчивый, переобучаемый, самонастраивающийся.