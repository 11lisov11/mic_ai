from __future__ import annotations

import argparse
import re
from pathlib import Path
from typing import Dict, Iterable, List, Tuple

import numpy as np
import torch

def _c_float(value: float) -> str:
    text = f"{float(value):.9g}"
    if "e" not in text.lower() and "." not in text:
        text += ".0"
    return f"{text}f"


def _strip_prefix(state: Dict[str, torch.Tensor], prefix: str) -> Dict[str, torch.Tensor]:
    if not prefix:
        return state
    out: Dict[str, torch.Tensor] = {}
    for key, value in state.items():
        if key.startswith(prefix):
            out[key[len(prefix) :]] = value
        else:
            out[key] = value
    return out


def _normalize_state_dict(obj: object) -> Dict[str, torch.Tensor]:
    if isinstance(obj, dict) and all(isinstance(k, str) for k in obj.keys()):
        # Fast-path: looks like a state_dict already.
        if all(isinstance(v, torch.Tensor) for v in obj.values()):
            state = obj  # type: ignore[assignment]
        elif "state_dict" in obj and isinstance(obj["state_dict"], dict):
            state = obj["state_dict"]  # type: ignore[assignment]
        else:
            # Try nested common keys.
            for key in ("net", "model", "actor", "policy"):
                if key in obj and isinstance(obj[key], dict):
                    maybe = obj[key]
                    if all(isinstance(v, torch.Tensor) for v in maybe.values()):
                        state = maybe
                        break
            else:
                raise ValueError("Unsupported checkpoint format: cannot find a torch state_dict")
    else:
        raise ValueError("Unsupported checkpoint format: expected dict-like object")

    # Strip common wrappers.
    state = _strip_prefix(state, "module.")
    state = _strip_prefix(state, "net.")
    return state


def _extract_actor_layers(state: Dict[str, torch.Tensor]) -> List[Tuple[np.ndarray, np.ndarray]]:
    linear_indices: List[int] = []
    pattern = re.compile(r"^actor_body\.(\d+)\.weight$")
    for key in state.keys():
        match = pattern.match(key)
        if match:
            linear_indices.append(int(match.group(1)))

    if not linear_indices:
        raise ValueError("No actor_body.*.weight found in checkpoint state_dict")

    linear_indices.sort()
    layers: List[Tuple[np.ndarray, np.ndarray]] = []
    for idx in linear_indices:
        w_key = f"actor_body.{idx}.weight"
        b_key = f"actor_body.{idx}.bias"
        if w_key not in state:
            raise KeyError(f"Missing {w_key} in checkpoint")
        if b_key not in state:
            raise KeyError(f"Missing {b_key} in checkpoint")
        w = state[w_key].detach().cpu().numpy().astype(np.float32, copy=False)
        b = state[b_key].detach().cpu().numpy().astype(np.float32, copy=False)
        layers.append((w, b))

    # Output layer (actor head)
    if "actor_head.weight" not in state or "actor_head.bias" not in state:
        raise KeyError("Missing actor_head.(weight|bias) in checkpoint")
    w_out = state["actor_head.weight"].detach().cpu().numpy().astype(np.float32, copy=False)
    b_out = state["actor_head.bias"].detach().cpu().numpy().astype(np.float32, copy=False)
    layers.append((w_out, b_out))

    return layers


def _emit_array_2d(name: str, arr: np.ndarray) -> str:
    out_dim, in_dim = arr.shape
    lines = [f"static const float {name}[{out_dim}][{in_dim}] = {{\n"]
    for row in arr:
        items = ", ".join(_c_float(v) for v in row.tolist())
        lines.append(f"  {{{items}}},\n")
    lines.append("};\n")
    return "".join(lines)


def _emit_array_1d(name: str, arr: np.ndarray) -> str:
    items = ", ".join(_c_float(v) for v in arr.tolist())
    return f"static const float {name}[{arr.shape[0]}] = {{{items}}};\n"


def export_actor_to_c_header(checkpoint: str | Path, out_path: str | Path, symbol_prefix: str = "mic_ai_actor") -> Path:
    checkpoint = Path(checkpoint)
    out_path = Path(out_path)
    out_path.parent.mkdir(parents=True, exist_ok=True)

    raw = torch.load(checkpoint, map_location="cpu")
    state = _normalize_state_dict(raw)
    layers = _extract_actor_layers(state)

    if len(layers) != 3:
        raise ValueError(f"Expected 2 hidden layers + output (3 linear layers), got {len(layers)}")

    (w0, b0), (w1, b1), (w2, b2) = layers
    in_dim = int(w0.shape[1])
    h1 = int(w0.shape[0])
    h2 = int(w1.shape[0])
    out_dim = int(w2.shape[0])

    if w1.shape != (h2, h1):
        raise ValueError(f"Unexpected W1 shape {w1.shape}, expected ({h2}, {h1})")
    if w2.shape[1] != h2:
        raise ValueError(f"Unexpected W2 in_dim {w2.shape[1]}, expected {h2}")

    prefix_upper = symbol_prefix.upper()
    parts: List[str] = []
    parts.append("// Auto-generated by mic_ai.tools.export_policy_c\n")
    parts.append("// Actor network: tanh(Linear) -> tanh(Linear) -> tanh(Linear)\n")
    parts.append("#pragma once\n\n")
    parts.append(f"#define {prefix_upper}_IN_DIM {in_dim}\n")
    parts.append(f"#define {prefix_upper}_H1_DIM {h1}\n")
    parts.append(f"#define {prefix_upper}_H2_DIM {h2}\n")
    parts.append(f"#define {prefix_upper}_OUT_DIM {out_dim}\n\n")

    parts.append(_emit_array_2d(f"{symbol_prefix}_W0", w0))
    parts.append(_emit_array_1d(f"{symbol_prefix}_b0", b0))
    parts.append("\n")
    parts.append(_emit_array_2d(f"{symbol_prefix}_W1", w1))
    parts.append(_emit_array_1d(f"{symbol_prefix}_b1", b1))
    parts.append("\n")
    parts.append(_emit_array_2d(f"{symbol_prefix}_W2", w2))
    parts.append(_emit_array_1d(f"{symbol_prefix}_b2", b2))
    parts.append("\n")

    out_path.write_text("".join(parts), encoding="utf-8")
    return out_path


def parse_args(argv: Iterable[str] | None = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Export PPO actor weights to a C header (static const arrays).")
    parser.add_argument("--checkpoint", required=True, help="Path to .pth checkpoint (state_dict).")
    parser.add_argument("--out", required=True, help="Output .h path.")
    parser.add_argument("--prefix", default="mic_ai_actor", help="C symbol prefix (default: mic_ai_actor).")
    return parser.parse_args(list(argv) if argv is not None else None)


def main(argv: Iterable[str] | None = None) -> int:
    args = parse_args(argv)
    export_actor_to_c_header(args.checkpoint, args.out, symbol_prefix=args.prefix)
    print(f"Exported actor header to {args.out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
